/*
  * Leight weight variant of the gcc's gcov-library.
  *
  * This code is based on gcc_3_4.c  from gcc 4.7 and the Linux kernel code
  * kernel/gcov.
  *
  * This code provides functions to handle gcc's profiling data format
  * introduced with gcc 4.7. It basically uses the convert_to_gcda function to
  * generate the .gcda files information upon application completion, and dump
  * it on the serial console.
  *
  * Special thanks to
  *   Aitorvs: https://github.com/aitorvs/tiny-coverage
  *   Tejainece: https://github.com/tejainece/tcov
  *   Erich Styger: https://mcuoneclipse.com/2014/12/26/code-coverage-for-embedded-target-with-eclipse-gcc-and-gcov
  *
 */

#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include "coverage.h"

#if __GNUC__ == 5 && __GNUC_MINOR__ >= 1
#define GCOV_COUNTERS                   10
#elif __GNUC__ == 4 && __GNUC_MINOR__ >= 9
#define GCOV_COUNTERS                   9
#else
#define GCOV_COUNTERS                   8
#endif

typedef uint64_t gcov_type;

#define GCOV_WORD_SIZE 4
#define GCOV_TAG_FUNCTION_LENGTH  3
#define GCOV_DATA_MAGIC   ((uint32_t) 0x67636461)
#define GCOV_TAG_FUNCTION ((uint32_t) 0x01000000)
#define GCOV_TAG_COUNTER_BASE ((uint32_t) 0x01a10000)
#define GCOV_TAG_OBJECT_SUMMARY  ((uint32_t)0xa1000000)
#define GCOV_TAG_OBJECT_SUMMARY_LENGTH  (2 * GCOV_WORD_SIZE)
#define GCOV_TAG_FOR_COUNTER(count)         \
(GCOV_TAG_COUNTER_BASE + ((uint32_t) (count) << 17))
#define GCOV_COUNTER_LENGTH(count)         \
(count * 2)

/**Information about counters for a single function
 *
 * This data is generated by gcc during compilation and doesn't change
 *  at run-time with the exception of the values array.
 */
struct gcov_ctr_info {
  uint32_t num;   // number of counter values for this type
  gcov_type *values;  // array of counter values for this type
};

/**
 * Profiling meta data per function
 *
 * This data is generated by gcc during compilation and doesn't change
 * at run-time.
 *
 * Information about a single function.  This uses the trailing array
 * idiom. The number of counters is determined from the merge pointer
 * array in gcov_info.  The key is used to detect which of a set of
 * comdat functions was selected -- it points to the gcov_info object
 * of the object file containing the selected comdat function.
 */
struct gcov_fn_info {
  const struct gcov_info *key;    // comdat key
  uint32_t ident;             // unique ident of function
  uint32_t lineno_checksum;   // function lineo_checksum
  uint32_t cfg_checksum;      // function cfg checksum
  struct gcov_ctr_info ctrs[1];   // instrumented counters
};

// type of merge functions
typedef void (*gcov_merge_fn) (gcov_type *, uint32_t);
/** Profiling data per object file
 *
 * This data is generated by gcc during compilation and doesn't change
 * at run-time with the exception of the next pointer. */
struct gcov_info {

  uint32_t version;	/* expected version number */
  struct gcov_info *next;	/* link to next, used by libgcov */

  uint32_t stamp;	/* uniquifying time stamp */
  const char *filename;		/* output file name */
  uint32_t checksum;	/* unique object checksum */

  gcov_merge_fn merge[GCOV_COUNTERS];  /* merge functions (null for
					  unused) */
  
  uint32_t n_functions;		/* number of functions */

  const struct gcov_fn_info **functions; /* pointer to pointers
                                                      to function information  */
};

struct gcov_summary {
  uint32_t runs;		/* Number of program runs.  */
  gcov_type sum_max;    	/* Sum of individual run max values.  */
};

static struct gcov_info *gcov_info_head;

/**
 * Is called by gcc-generated constructor code for each object file compiled
 * with -fprofile-arcs.
 * @param info
 */
void __gcov_init(struct gcov_info *info) {
  info->next = gcov_info_head;
  gcov_info_head = info;
}

void __gcov_exit(struct gcov_info *info) {
}

void __gcov_merge_add(gcov_type *counters, uint32_t n_counters) {
  /* Unused. */
}

/**
 * store_gcov_u64 - store 64 bit number in gcov format to buffer
 * @buffer: target buffer or NULL
 * @off: offset into the buffer
 * @v: value to be stored
 *
 * Number format defined by gcc: numbers are recorded in the 32 bit
 * unsigned binary form of the endianness of the machine generating the
 * file. 64 bit numbers are stored as two 32 bit numbers, the low part
 * first. Returns the number of bytes stored. If @buffer is %NULL, doesn't store
 * anything.
 */
static size_t store_gcov_u64(void *buffer, size_t off, uint64_t v) {
  uint32_t *data;
  if (buffer) {
    data = buffer + off;
    /*
    // Swap endianness
    uint64_t swapped = ((v >> 56) |
            (v & 0x00ff000000000000) >> 40 |
            (v & 0x0000ff0000000000) >> 24 |
            (v & 0x000000ff00000000) >> 8 |
            (v & 0x00000000ff000000) << 8 |
            (v & 0x0000000000ff0000) << 24 |
            (v & 0x000000000000ff00) << 40 |
            (v << 56)
            );
            */
    data[0] = (v & 0xffffffffUL);
    data[1] = (v >> 32);
  }
  return sizeof(*data) * 2;
}

/**
 * store_gcov_u32 - store 32 bit number in gcov format to buffer
 * @buffer: target buffer or NULL
 * @off: offset into the buffer
 * @v: value to be stored
 *
 * Number format defined by gcc: numbers are recorded in the 32 bit
 * unsigned binary form of the endianness of the machine generating the
 * file. Returns the number of bytes stored. If @buffer is %NULL, doesn't
 * store anything.
 */
static size_t store_gcov_u32(void *buffer, size_t off, uint32_t v) {
  uint32_t *data;
  if (buffer) {
    /* uint32_t swapped = ((v>>24)&0xff) | // move byte 3 to byte 0
                    ((v<<8)&0xff0000) | // move byte 1 to byte 2
                    ((v>>8)&0xff00) | // move byte 2 to byte 1
                    ((v<<24)&0xff000000); // byte 0 to byte 3
                                          //
                                          */
    data = buffer + off;
    *data = v;
  }
  return sizeof(*data);
}

/**
 * Determine whether a counter is active. Doesn't change at run-time.
 */
static int counter_active(struct gcov_info *info, uint32_t type) {
  return info->merge[type] ? 1 : 0;
  // return 1;
}

/**
 * convert_to_gcda - convert profiling data set to gcda file format
 * @buffer: the buffer to store file data or %NULL if no data should be stored
 * @info: profiling data set to be converted
 *
 * Returns the number of bytes that were/would have been stored into the buffer.
 */
size_t convert_to_gcda(uint8_t *buffer, struct gcov_info *info, struct gcov_summary *summary) {
  struct gcov_fn_info *fi_ptr;
  struct gcov_ctr_info *ci_ptr;
  uint32_t fi_idx;
  uint32_t ct_idx;
  uint32_t cv_idx;
  size_t pos = 0;

  /* File header. */
  pos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);
  pos += store_gcov_u32(buffer, pos, info->version);
  pos += store_gcov_u32(buffer, pos, info->stamp);

  pos += store_gcov_u32(buffer, pos, GCOV_TAG_OBJECT_SUMMARY);
  pos += store_gcov_u32(buffer, pos, GCOV_TAG_OBJECT_SUMMARY_LENGTH);
  pos += store_gcov_u32(buffer, pos, summary->runs);
  pos += store_gcov_u64(buffer, pos, summary->sum_max);

  for (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {
    fi_ptr = info->functions[fi_idx];

    /* Function record. */
    pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);
    pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);
    pos += store_gcov_u32(buffer, pos, fi_ptr->ident);
    pos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);
    pos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);

    ci_ptr = fi_ptr->ctrs;

    info->merge[0] = __gcov_merge_add;

    for (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {
      if (!counter_active(info, ct_idx))
        continue;

      /* Counter record. */
      pos += store_gcov_u32(buffer, pos, GCOV_TAG_FOR_COUNTER(ct_idx));
      pos += store_gcov_u32(buffer, pos, GCOV_COUNTER_LENGTH(ci_ptr->num));

      for (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {
        pos += store_gcov_u64(buffer, pos, ci_ptr->values[cv_idx]);
      }

      ci_ptr++;
    }
  }
  pos += store_gcov_u32(buffer, pos, 0);
  return pos;
}

/**
 * Dumps the coverage data to file system
 * @return Zero on success
 * @note Using the subs in syscalls.c will use a kind of leight weight filesystem which uses the serial interface to transfer the coverage data from the embedded platform to a host computer.
 */
int coverage_dump() {
  struct gcov_info *tmp = gcov_info_head;
  struct gcov_summary summary = {
      .runs = 1,
      .sum_max = 1,
  };
  uint8_t buff[10240] = { 0 };
  while (tmp) {
    int f, ret;
    // uint8_t *buffer;
    // size_t size = convert_to_gcda(NULL, tmp);
    // buffer = (uint6_t*) malloc(size);
    // if (!buff)
    //   return -ENOMEM;
    size_t size = convert_to_gcda(buff, tmp, &summary);

    f = open(tmp->filename, O_WRONLY | O_CREAT, 0644);  // Calls _open in syscalls
    ret = write(f, buff, size);   // Calls _write in syscalls
    if(ret != size)
      return ret;

    // free(buffer);
    tmp = tmp->next;
  }
  return 0;
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){
    coverage_dump();
}

